<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="rgb(46, 44, 79)">
  <meta name="description" content="linux 的简单应用">
  <meta name="keywords" content="Linux, Config">
  <title>
    linux
  </title>
  <link rel="stylesheet" href="/public/css/index.css">
  <link rel="stylesheet" href="/public/css/markdown.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
  <script src="/public/JavaScript/index.js"></script>
</head><header class="blog-header">
  <a href="https://github.com/fwqaaq" target="_blank">
    <img src="https://avatars.githubusercontent.com/u/82551626?v=4" loading="lazy" alt="me" srcset="">
  </a>
  <nav class="header-nav">
    <a class="decoration-line" href="/"><i class="fa-solid fa-house-chimney fa-xs"></i>
      <span class="disappear">Home</span>
    </a>
    <a class="decoration-line" href="/./about/index.html"><i class="fa-solid fa-address-card fa-xs"></i>
      <span class="disappear">About</span></a>
    <a class="decoration-line" href="/./archive/index.html"><i class="fa-solid fa-box-archive fa-xs"></i> <span
        class="disappear">Archive</span></a>
    <a class="decoration-line" href="/./tags/index.html"><i class="fa-solid fa-tag fa-xs"></i> <span
        class="disappear">Tag</span></a>
    <div class="toy"><i class="fa-solid fa-gamepad fa-xs"></i> <span class="disappear">Toy</span>
      <nav class="toy-nav disappear">
        <a class="decoration-line" href="/public/resume/">我的简历</a>
        <a class="decoration-line" href="/public/write-css/index.html">学习 UI</a>
      </nav>
    </div>
    <a class="decoration-line" href="/feed.xml"><i class="fa-solid fa-rss fa-xs"></i> <span
        class="disappear">RSS</span></a>
    <a class="decoration-line model" href="#" class="model"><i class="fa-solid fa-sun fa-xs"></i></a>
  </nav>
</header><main class="blog-main">
          <article class="blog-article">
            <h1>linux</h1>
            <hr>
            <h2 id="linux-目录">linux 目录<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#linux-目录"></a></h2>

































































































<table><thead><tr><th>目录</th><th>解释</th></tr></thead><tbody><tr><td><strong>/bin</strong></td><td>存放最常使用的命令</td></tr><tr><td><strong>/boot</strong></td><td>启动 Linux 时使用的一些核心文件</td></tr><tr><td><strong>/dev</strong></td><td>存放 linux 外部的设备，在 linux 中访问设备的方式和访问文件的方式是相同的</td></tr><tr><td><strong>/etc</strong></td><td>这个目录用来存放所有的系统管理所需的配置文件和子目录</td></tr><tr><td><strong>/home</strong></td><td>用户的主目录，在 linux 中共每个用户都有一个自己的目录，一般该目录是由用户账号命名</td></tr><tr><td><strong>/lib</strong></td><td>这个目录存放系统最基本的动态连接共享库，类似于 windows 的 dll 文件</td></tr><tr><td><strong>/lost+found</strong></td><td>一般情况是空的，非法关机后，就会存放一些文件</td></tr><tr><td><strong>/media</strong></td><td>识别设备 (例如 u 盘等) 识别后，linux 会把识别的设备挂载到这个目录</td></tr><tr><td><strong>/mnt</strong></td><td>让用户临时挂别的文件系统，可以将光驱挂载在<code>/mnt</code></td></tr><tr><td><strong>/opt</strong></td><td>这是给主机额外安装软件所摆放的</td></tr><tr><td><strong>/proc</strong></td><td>虚拟目录。存放系统内存的映射</td></tr><tr><td><strong>/root</strong></td><td>系统管理员</td></tr><tr><td><strong>/run</strong></td><td>临时文件系统，存储系统启动依赖的信息.(重启会被删掉)</td></tr><tr><td><strong>/sbin</strong></td><td>存放的是使用的系统管理程序</td></tr><tr><td><strong>/srv</strong></td><td>存放一些服务启动之后需要提取的数据</td></tr><tr><td><strong>/sys</strong></td><td>2.6 之后才有的。该目录安装了 2.6 内核中出现的新的文件系统 sysfs</td></tr><tr><td><strong>/tmp</strong></td><td>存放临时文件，用完即删</td></tr><tr><td><strong>/usr</strong></td><td>用户的很多程序文件都在这个目录下，类似于<code>program files</code></td></tr><tr><td><strong>/usr/bin</strong></td><td>系统用户使用的应用程序</td></tr><tr><td><strong>/usr/sbin</strong></td><td>超级用户使用的比较高级的管理员程序和系统守护程序</td></tr><tr><td><strong>/usr/src</strong></td><td>内核源代码默认存放的目录</td></tr><tr><td><strong>/var</strong></td><td>这个目录存放着不断扩充的东子</td></tr></tbody></table>
<h2 id="常用命令">常用命令<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#常用命令"></a></h2>
<h3 id="查看文件属性和修改">查看文件属性和修改<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#查看文件属性和修改"></a></h3>
<ul>
<li>
<p>第一个 root 是<code>属主</code>,第二个 root 是<code>属组</code></p>
</li>
<li>
<p>关于第一个字符的含义</p>
<ol>
<li><code>-d</code>:代表是目录</li>
<li><code>-</code>:代表的是文件</li>
<li><code>-l</code>:代表的是链接文档 (<code>link file</code>)</li>
<li><code>b</code>:表示为装置文件里面的可供储存的接口设备 (可随机存取的装置)</li>
<li><code>c</code>:表示为装置文件里卖弄的串行端口设备 (键盘，鼠标等一次性读取装置)</li>
</ol>
</li>
<li>
<p>剩下字符的含义</p>
<ol>
<li><code>r</code>:表示可读</li>
<li><code>w</code>:表示可写</li>
<li><code>x</code>:代表可执行</li>
<li><code>-</code>:代表没有这个权限</li>
</ol>
</li>
</ul>
<blockquote>
<p>修改文件属性</p>
</blockquote>
<ol>
<li><strong>chagrp:更改文件数组</strong>
<ul>
<li><code>chgrp [-R] 属组名 文件名</code></li>
<li><code>-R</code>:递归更改文件属组。放在更改某文件的同时，他目录下的所有文件属性都会更改</li>
</ul>
</li>
<li><strong>chown:更改文件属主，也可以同时更改文件属组</strong>
<ul>
<li><code>chown [-R] 属主名 文件名</code></li>
<li><code>chown [-R] 属主名:属组名 文件名</code></li>
</ul>
</li>
<li><strong>chmod:更改文件 9 个属性</strong>（最重要）
<ul>
<li><code>chmod [-R] xyz 文件或者目录</code></li>
<li>两种设置：一种是数字 (常用) 一种是符号</li>
<li>基本权限：<code>owner/group/others</code>每个都有自己身份的<code>read/write/execute</code>(途中的两个 root 分别就是主和组)</li>
</ul>
</li>
<li>每个字符对应的数字</li>
</ol>
<pre><code class="hl language-shell">r:4   w:2   x:1
chmod 770 filename # rwxrwx---
</code></pre>
<ul>
<li>例如：<code>chmod 777 filename</code>:赋予文件最高权限</li>
</ul>
<h3 id="文件内容查看">文件内容查看<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#文件内容查看"></a></h3>
<ul>
<li><code>cat</code>:从第一行开始显示文件的内容</li>
<li><code>tac</code>:从最后一行显示文件的内容</li>
<li><code>nl</code>:现实的时候顺道输出行号</li>
<li><code>more</code>:一页一页的显示文件内容 (空格代表翻页，enter 代表按行向下翻)</li>
<li><code>less</code>:与 more 相比，可以往前翻页 (上下键，q 是退出)
<ul>
<li>查询：<code>/+查询字符</code>从头到尾向下查询，<code>?+查询字符</code>从尾到头向下查询</li>
</ul>
</li>
<li><code>head</code>:只有头几行</li>
<li><code>tail</code>:只有尾几行</li>
</ul>
<blockquote>
<p><code>/etc/sysconfig/network-scripts</code>:linux 网络配置文件</p>
</blockquote>
<h3 id="linux-链接的概念">linux 链接的概念<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#linux-链接的概念"></a></h3>
<ul>
<li>
<p><strong>硬链接</strong>:硬链接相当于指向的是文件实际存储路径。可以使用这种机制建立到一些重要文件，防止误删</p>
</li>
<li>
<p><strong>软链接</strong>:软连接相当于指向文件路径，删除源文件，就访问不了</p>
</li>
<li>
<p>创建链接：<code>ln</code></p>
<ol>
<li>硬链接：<code>ln f1 f2</code>,创建 1 个 f1 的硬链接</li>
<li>软链接：<code>ln -s f1 f3</code>,s 代表软连接。创建 1 个 f1 的软链接<code>f3->f1</code></li>
</ol>
</li>
</ul>
<blockquote>
<p>ls -a 有箭头指向的是软连接</p>
</blockquote>
<h3 id="账号管理">账号管理<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#账号管理"></a></h3>
<ul>
<li>以下都需要 root 权限</li>
</ul>
<blockquote>
<p>一些云服务器会限制使用 root 或者<strong>密码登录</strong>，这时候我们需要更改它的默认配置</p>
</blockquote>
<ol>
<li>
<p>切换到 root 权限中，进入 sshd_config 配置文件中</p>
<pre><code class="hl language-bash">sudo -i
<span class="hl-built_in">cd</span> /etc/ssh/sshd_config
</code></pre>
</li>
<li>
<p>修改 sshd_config 配置文件</p>
<pre><code class="hl language-bash"><span class="hl-comment"># Authentication:</span>
PermitRootLogin <span class="hl-built_in">yes</span> //默认为 no，需要开启 root 用户访问改为 <span class="hl-built_in">yes</span>
<span class="hl-comment"># Change to no to disable tunnelled clear text passwords</span>
PasswordAuthentication <span class="hl-built_in">yes</span> //默认为 no，改为 <span class="hl-built_in">yes</span> 开启密码登陆
</code></pre>
</li>
<li>
<p>重新开启 sshd 服务</p>
<pre><code class="hl language-bash">systemctl restart sshd
<span class="hl-comment"># 或者是 ssh</span>
<span class="hl-comment"># systemctl restart ssh</span>
</code></pre>
</li>
<li>
<p>在 root 权限下更改 user 的密码</p>
<pre><code class="hl language-bash">passwd user
</code></pre>
</li>
</ol>
<blockquote>
<p>添加用户：<code>useradd -选项 用户名</code></p>
</blockquote>
<ul>
<li>
<p><code>-m</code>：使用者目录。没有则自动建立</p>
</li>
<li>
<p><code>-c</code>：指定一段注释性描述</p>
</li>
<li>
<p><code>-d</code>  目录：指定用户主目录，如果此目录不存在，则同时使用 <code>-m</code> 选项，可以创建主目录</p>
</li>
<li>
<p><code>-g</code> 用户组：指定用户所属的用户组</p>
</li>
<li>
<p><code>-G</code> 用户组：指定用户所属的附加组</p>
</li>
<li>
<p><code>-s</code> Shell：指定用户的登录 Shell</p>
</li>
<li>
<p><code>-u</code> 用户号：指定用户的用户号，如果同时有 <code>-o</code>，则可以重复使用其它用户的标识号</p>
</li>
<li>
<p><strong>创建用户的本质就是在 <code>/etc/password</code> 种写入一个用户的信息</strong></p>
</li>
</ul>
<blockquote>
<p>删除指定的用户：userdel 选项 用户名</p>
</blockquote>
<ul>
<li><code>-r</code>:删除用户的时候将他的目录也一起删掉</li>
</ul>
<blockquote>
<p>修改用户：usermod 选项 用户名</p>
</blockquote>
<ul>
<li><code>-m -c -d -g -G -s -u</code>：这些和以上的选项作用一样</li>
</ul>
<pre><code class="hl language-shell">[root@VM-12-17-centos home]# usermod -d /home/fw1314 fw
<span class="hl-meta prompt_">
# </span><span class="bash">在/etc/password查看</span>
fw:x:1001:1001::/home/fw1314:/bin/bash
</code></pre>
<h4 id="加入-sudo-用户组">加入 sudo 用户组<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#加入-sudo-用户组"></a></h4>
<blockquote>
<p>Ubuntu, kbuntu, debian, etc</p>
</blockquote>
<pre><code class="hl language-bash">usermod -a -G sudo user
</code></pre>
<blockquote>
<p>RedHat, Fedora, CentOS, etc</p>
</blockquote>
<pre><code class="hl language-bash">usermod -a -G wheel user
</code></pre>
<h3 id="切换用户">切换用户<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#切换用户"></a></h3>
<ol>
<li>切换用户的命令：<code>su username</code>(username 是用户名)</li>
<li>从普通的用户切换到 <code>root</code>：<code>su root</code> 需要输入密码</li>
<li>在终端输入 exit 或者 <code>ctrl+d</code> 也可以退回到原来的账号</li>
<li><code>hostname</code> 主机名：修改主机名</li>
</ol>
<blockquote>
<ul>
<li>root 给用户设置密码：<code>passwd 用户名</code></li>
<li>普通用户直接输入：<code>passwd</code>,修改密码</li>
</ul>
</blockquote>
<h3 id="锁定账户">锁定账户<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#锁定账户"></a></h3>
<blockquote>
<ul>
<li><code>passwd -l</code> 用户名：将该账户锁定</li>
<li><code>passwd -d</code> 用户名：将这个账户密码清空</li>
</ul>
</blockquote>
<h2 id="用户组管理">用户组管理<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#用户组管理"></a></h2>
<blockquote>
<p>每个用户都有一个用户组，系统可以对一个用户组种的所有用户进行集中管理 (例如开发，测试，运维，root 等).不同的 Linux 系统对用户组的规定有所不同</p>
<p>用户组的管理涉及用户组的添加，修改，删除。组的增加，删除和修改实际上就是对
<code>/etc/group</code> 文件的更新</p>
</blockquote>
<ul>
<li>创建一个用户组 <code>groupadd 组名</code>
<ul>
<li>查看 <code>cat /etc/group</code></li>
<li>创建完用户组可以得到一个组的 id <code>-g id</code>，如果不指定可以自增</li>
</ul>
</li>
</ul>
<pre><code class="hl language-shell">[root@VM-12-17-centos home]# groupadd fw1314 -g 120
<span class="hl-meta prompt_"># </span><span class="bash">fw1314:x:120:</span>
</code></pre>
<blockquote>
<p>删除用户组 <code>groupdel 组名</code></p>
<p>修改用户组的权限<code>groupmod 选项 组名</code></p>
</blockquote>
<ul>
<li><code>-g</code>：修改 id</li>
<li><code>-n</code>：修改组名</li>
</ul>
<blockquote>
<p>修改用户组 (一般直接在创建用户时使用 <code>-G</code> 分配组)</p>
</blockquote>
<ul>
<li>普通用户 <code>newgrp 组名</code></li>
</ul>
<h3 id="文件的查看">文件的查看<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#文件的查看"></a></h3>
<pre><code class="hl language-shell">root:x:0:0:root:/root:/bin/bash
</code></pre>
<ul>
<li><code>/etc/password</code>：用户名:口令 (登录密码，不可见):用户标识符:组标识号:注释性描述:主目录:登录 shell
<ul>
<li>每一行都代表一个用户，从中可以看出这个用户的主目录在哪，属于哪一个组</li>
<li>密码放在 <code>/etc/shadow</code> 中</li>
</ul>
</li>
</ul>
<h3 id="磁盘管理">磁盘管理<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#磁盘管理"></a></h3>
<ol>
<li><code>df</code>：列出文件系统整体的磁盘使用量 (<code>-h</code> 使用十进制表示)</li>
<li><code>du</code>：检查当前磁盘空间的使用量
<ul>
<li><code>du -sm /*</code>：检查根目录下所占用的容量</li>
</ul>
</li>
</ol>
<blockquote>
<p>Mac 或者用 Linux 挂载一些本地磁盘或者文件</p>
</blockquote>
<ul>
<li><code>mount /dev/fw /mnt/fw</code>：将外部设备 <code>/dev/fw</code> 挂载到 <code>/mnt/fw</code>，因为外部设备都会在 <code>/dev/fw</code> 中
<ul>
<li><code>umount</code>：卸载。<code>-f</code>强制卸载</li>
</ul>
</li>
</ul>
<h2 id="进程管理">进程管理<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#进程管理"></a></h2>
<p><code>ps 选项</code>:查看系统中正在进行的进程信息</p>
<p>选项 解释 -a 显示当前终端运行的所有进程信息 (当前的进程) -u 以用户的信息显示进程
-x 显示后台运行进程的参数</p>
<pre><code class="hl language-shell">A|B #使用A命令的结果来操作B命令
ps -aux # 查看所有的进程
</code></pre>
<ul>
<li><code>grep</code>:查找文件中符合条件的字符串</li>
</ul>
<pre><code class="hl language-shell">ps -aux | grep nginx
</code></pre>
<ul>
<li><strong>ps -ef</strong>:查看父进程的信息</li>
</ul>
<pre><code class="hl language-shell">ps -ef | grep nginx
<span class="hl-meta prompt_">
# </span><span class="bash">一般使用目录树结构查看</span>
pstree -pu
</code></pre>
<ul>
<li><strong>pstree</strong>:以目录树结构查看
<ul>
<li><code>-p</code>:显示父 id</li>
<li><code>-u</code>:显示用户组</li>
</ul>
</li>
</ul>
<h3 id="结束进程">结束进程<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#结束进程"></a></h3>
<ul>
<li><code>kill 进程id</code>:杀掉进程
<ul>
<li><code>-9</code>:强制杀掉进程</li>
</ul>
</li>
</ul>
<pre><code class="hl language-shell">kill -9 873518
</code></pre>
<h2 id="防火墙">防火墙<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#防火墙"></a></h2>
<ol>
<li>查看防火墙状态
<ul>
<li>查看防火墙状态 <code>systemctl status firewalld</code></li>
<li>开启防火墙 <code>systemctl start firewalld</code></li>
<li>关闭防火墙 <code>systemctl stop firewalld</code></li>
<li>开启防火墙 <code>service firewalld start</code></li>
</ul>
</li>
<li>查看对外开放的端口状态
<ul>
<li>查询已开放的端口 <code>netstat  -ntulp | grep 端口号</code>:可以具体查看某一个端口号</li>
<li>查看想开的端口是否已开：<code>firewall-cmd --query-port=6379/tcp</code></li>
<li>添加指定需要开放的端口：<code>firewall-cmd --add-port=123/tcp --permanent</code></li>
<li>重载入添加的端口：<code>firewall-cmd --reload</code></li>
<li>移除指定端口：<code>firewall-cmd --permanent --remove-port=123/tcp</code></li>
</ul>
</li>
<li>若遇到无法开启
<ul>
<li>先用：<code>systemctl unmask firewalld.service</code></li>
<li>然后：<code>systemctl start firewalld.service</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>由于你开了防火墙的同时，可能还有 docker 服务，会遇到如下错误</p>
</blockquote>
<pre><code class="hl language-Shell">Error response from daemon: driver failed programming external connectivity on endpoint quirky_allen (4127da7466709fd45695a1fbe98e13c2ac30c2a554e18fb902ef5a03ba308438): (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 9000 -j DNAT --to-destination 172.17.0.2:80 ! -i docker0: iptables: No chain/target/match by that name.
(exit status 1))
</code></pre>
<ul>
<li><code>firewall</code> 的底层是使用 <code>iptables</code> 进行数据过滤，建立在 <code>iptables</code> 之上，这可能会与 <code>Docker</code> 产生冲突。</li>
</ul>
<p>当 firewalld 启动或者重启的时候，将会从 iptables 中移除 DOCKER 的规则，从而影响了
Docker 的正常工作。</p>
<p>当你使用的是 Systemd 的时候，firewalld 会在 Docker 之前启动，但是如果你在 <code>Docker</code> 启动之后再启 或者重启 <code>firewalld</code>，你就需要重启 Docker 进程了</p>
<pre><code class="hl language-shell">systemctl restart docker
</code></pre>
<h2 id="env">env<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#env"></a></h2>
<ol>
<li>
<p><code>env</code>:查看所有环境变量</p>
<pre><code class="hl language-Shell">env
</code></pre>
</li>
<li>
<p><code>export</code>:查看所有环境变量</p>
<ul>
<li><code>export PATH="..."</code>: 在 PATH 最后添加指定变量 (环境变量)</li>
<li>指定的环境变量立即生效</li>
</ul>
<pre><code class="hl language-shell">source /etc/profile
</code></pre>
<ul>
<li>如果要删除某个环境变量，首先使用 <code>echo $PATH</code> 获取所有环境变量，然后使用
<code>export PATH="..."</code> 来指定不要删除的环境变量 (排除删除的即可)</li>
</ul>
</li>
</ol>
<h2 id="scp">scp<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#scp"></a></h2>
<blockquote>
<p>假设我们有两台主机 A and B，但是我们现在在主机 A 中</p>
</blockquote>
<ol>
<li>
<p>如果我们想要将主机 A 的文件拷贝到主机 B</p>
<pre><code class="hl language-bash"><span class="hl-variable">$scp</span> -r local_folder remote_username@remote_ip:remote_folder
<span class="hl-comment"># 如果已经有对方公钥的情况</span>
<span class="hl-variable">$scp</span> -r local_folder remote_ip:remote_folder
</code></pre>
</li>
</ol>
<h2 id="curl">curl<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#curl"></a></h2>
<blockquote>
<p>使用 <code>curl url</code> 可以返回对方的响应地址，默认是 get 请求</p>
</blockquote>
<pre><code class="hl language-bash">curl <span class="hl-string">'https://s1.hdslb.com/bfs/seed/bplus-common/icon-font/2.1.2/bp-icon-font.css'</span>
</code></pre>
<ul>
<li>如果需要发送 post 请求，需要 <code>curl -X -POST url</code> 来发送，当然也可以将 X 和
POST 合起来写 <code>-XPOST</code>
<ul>
<li>如果要返回数据，需要添加 -d 标志</li>
</ul>
</li>
</ul>
<pre><code class="hl language-bash"><span class="hl-comment"># 添加 json 格式的数据</span>
curl -XPOST url -d <span class="hl-string">'{"fw":"me"}'</span>
</code></pre>
<ul>
<li>更新数据 <code>-XPUT</code></li>
</ul>
<pre><code class="hl language-bash">curl -XPUT url -d <span class="hl-string">'{"update":"更新数据"}'</span>
</code></pre>
<ul>
<li>删除数据 <code>-XDELETE</code></li>
</ul>
<blockquote>
<p>如果我们需要添加 header 信息，需要使用 <code>-H</code> 选项</p>
</blockquote>
<pre><code class="hl language-bash"><span class="hl-comment"># 如果需要多个 header，可以添加多个 -H，例如 -H ... -H ...</span>
curl -XPOST url -H <span class="hl-string">'Content-Type:application/json'</span> -d <span class="hl-string">'{"fw":"me"}'</span>
</code></pre>
<ul>
<li>如果我们想要获取到响应的 header 信息，可以使用 <code>curl -I url</code></li>
</ul>
<pre><code class="hl language-bash">curl -I <span class="hl-string">'https://s1.hdslb.com/bfs/seed/bplus-common/icon-font/2.1.2/bp-icon-font.css'</span>
</code></pre>
<blockquote>
<p>如果目标端有资源需要处理，需要使用 <code>curl -O url</code>,
会将资源直接下载到当前的目标的文件夹中</p>
</blockquote>
<pre><code class="hl language-bash">curl -O <span class="hl-string">'https://s1.hdslb.com/bfs/seed/bplus-common/icon-font/2.1.2/bp-icon-font.css'</span>
</code></pre>
<ul>
<li>当然，如果使用 <code>-o filename</code> 就可以修改文件名</li>
</ul>
<pre><code class="hl language-bash">curl -o fw.css <span class="hl-string">'https://s1.hdslb.com/bfs/seed/bplus-common/icon-font/2.1.2/bp-icon-font.css'</span>
</code></pre>
<ul>
<li>如果下载大文件，并且想要限制速度，可以使用 <code>--limit-rate</code> 速度
(不设置单位默认是<strong>字节</strong>)</li>
</ul>
<pre><code class="hl language-bash">curl --limit-rate 100k -o fw.css <span class="hl-string">'https://s1.hdslb.com/bfs/seed/bplus-common/icon-font/2.1.2/bp-icon-font.css'</span>
</code></pre>
<ul>
<li>如果下载中止（可能是 <kbd>ctrl</kbd>+<kbd>c</kbd>）这时候可以使用 <code>-C</code> 其它命令</li>
</ul>
<pre><code class="hl language-bash"><span class="hl-comment">#因为这里不需要其他参数，所以 -C 后跟 -</span>
curl -C - -o fw.css <span class="hl-string">'https://s1.hdslb.com/bfs/seed/bplus-common/icon-font/2.1.2/bp-icon-font.css'</span>
</code></pre>
<blockquote>
<p>curl 默认不会跟着重定向</p>
</blockquote>
<ul>
<li>为了跟着重定向，我们需要使用 <code>-L</code></li>
</ul>
<pre><code class="hl language-bash">curl https://www.bilibili.com -L
</code></pre>
<blockquote>
<p>如果想要查看连接的所有信息，需要使用 <code>-v</code></p>
</blockquote>
<pre><code class="hl language-bash">curl -v https://www.bilibili.com -L
</code></pre>
<ul>
<li>使用代理去请求（<code>--proxy</code>），一般情况下，这个都是需要账户和密码的</li>
</ul>
<pre><code class="hl language-bash">curl --proxy <span class="hl-string">"https://xxx@ip:port"</span> url
</code></pre>
<ul>
<li>如果是 ftp 协议，需要用户名和密码，那么就可以用小写的 <code>-u</code> 来指定</li>
</ul>
<pre><code class="hl language-bash">curl -u user:password -O ftp://server/xxx
</code></pre>
<ul>
<li>如果上传文件，需要增加 <code>-T</code> 后面跟着文件名</li>
</ul>
<pre><code class="hl language-bash">curl -u user:password -T file ftp://server/xxx
</code></pre>
<h2 id="alias">alias<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#alias"></a></h2>
<p>设置别名</p>
<pre><code class="hl language-bash"><span class="hl-built_in">alias</span> <span class="hl-built_in">rm</span>=<span class="hl-string">"rm i"</span>
</code></pre>
<p>取消别名</p>
<pre><code class="hl language-bash"><span class="hl-built_in">unalias</span> <span class="hl-built_in">rm</span>
</code></pre>
<h2 id="命令历史">命令历史<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#命令历史"></a></h2>
<p>查看所有命令历史</p>
<pre><code class="hl language-bash"><span class="hl-built_in">history</span>
</code></pre>
<p>查看上一条命令</p>
<pre><code class="hl language-bash">!!
</code></pre>
<h2 id="快捷键">快捷键<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#快捷键"></a></h2>
<ul>
<li>ctrl + a 移动到行首</li>
<li>ctrl + e 移动到行尾</li>
<li>ctrl + u 删光所有字符</li>
<li>ctrl + k 删除光标之后到</li>
<li>ctrl + l 清空屏幕终端的内容</li>
</ul>
<h2 id="文本处理工具">文本处理工具<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#文本处理工具"></a></h2>
<ol>
<li>grep: 文本过滤工具（模式：pattern）</li>
<li>sed: stream editor；文本编辑工具</li>
<li>awk: 文本报告生成器（支持格式化文本）</li>
</ol>
        </article></main><script src="https://giscus.app/client.js"
        data-repo="fwqaaq/fwqaaq.github.io"
        data-repo-id="R_kgDOHCFK2A"
        data-category="Show and tell"
        data-category-id="DIC_kwDOHCFK2M4CYOLh"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async></script>