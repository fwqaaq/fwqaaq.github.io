<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="rgb(46, 44, 79)">
  <meta name="description" content="reflect 反射">
  <meta name="keywords" content="JavaScript, TypeScript">
  <title>
    Reflect
  </title>
  <link rel="stylesheet" href="/public/css/index.css">
  <link rel="stylesheet" href="/public/css/markdown.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
  <script src="/public/JavaScript/index.js"></script>
</head><header class="blog-header">
  <a href="https://github.com/fwqaaq" target="_blank">
    <img src="https://avatars.githubusercontent.com/u/82551626?v=4" loading="lazy" alt="me" srcset="">
  </a>
  <nav class="header-nav">
    <a class="decoration-line" href="/"><i class="fa-solid fa-house-chimney fa-xs"></i>
      <span class="disappear">Home</span>
    </a>
    <a class="decoration-line" href="/./about/index.html"><i class="fa-solid fa-address-card fa-xs"></i>
      <span class="disappear">About</span></a>
    <a class="decoration-line" href="/./archive/index.html"><i class="fa-solid fa-box-archive fa-xs"></i> <span
        class="disappear">Archive</span></a>
    <a class="decoration-line" href="/./tags/index.html"><i class="fa-solid fa-tag fa-xs"></i> <span
        class="disappear">Tag</span></a>
    <div class="toy"><i class="fa-solid fa-gamepad fa-xs"></i> <span class="disappear">Toy</span>
      <nav class="toy-nav disappear">
        <a class="decoration-line" href="/public/resume/">我的简历</a>
        <a class="decoration-line" href="/public/write-css/index.html">学习 UI</a>
      </nav>
    </div>
    <a class="decoration-line" href="/feed.xml"><i class="fa-solid fa-rss fa-xs"></i> <span
        class="disappear">RSS</span></a>
    <a class="decoration-line model" href="#" class="model"><i class="fa-solid fa-sun fa-xs"></i></a>
  </nav>
</header><main class="blog-main">
          <article class="blog-article">
            <h1>Reflect</h1>
            <hr>
            <h2 id="reflect">Reflect<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflect"></a></h2>
<ol>
<li>Reflect 并非一个构造函数，不能通过 new 运算符对其进行调用，或者将 Reflect 对象作为一个函数来调用 (将原本 Object 命令式改为函数行为)
<ul>
<li><code>'assign' in Object</code></li>
<li><code>Reflect.has(Object, 'assign')</code></li>
</ul>
</li>
<li>Reflect 的所有属性和方法都是静态的</li>
<li>Reflect 提供了以下静态方法与 proxy handler methods(en-US) 的命名相同</li>
<li>其中的一些方法 Object 相同，
尽管二者之间存在某些细微上的差别。即 Reflect 对象上可以拿到语言内部的方法</li>
</ol>
<h3 id="reflectapply">Reflect.apply()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectapply"></a></h3>
<blockquote>
<p>过指定的参数列表发起对目标 (target) 函数的调用</p>
</blockquote>
<ul>
<li>注意：如果 target 对象不可调用，抛出 TypeError</li>
<li>调用完带着指定参数和 this 值的给定的函数后返回的结果</li>
</ul>
<ol>
<li><code>target</code>:目标函数</li>
<li><code>thisArgument</code>:target 函数调用时绑定的 this 对象</li>
<li><code>argumentsList</code>:target 函数调用时传入的实参列表 l，该参数应该是一个类数组的对象</li>
</ol>
<pre><code class="hl language-js"><span class="hl-title class_">Reflect</span>.<span class="hl-title function_">apply</span>(<span class="hl-title class_">RegExp</span>.<span class="hl-property"><span class="hl-keyword">prototype</span></span>.<span class="hl-property">test</span>, <span class="hl-regexp">/ab/</span>, [<span class="hl-string">"confabulation"</span>]);
<span class="hl-comment">//true</span>
</code></pre>
<h3 id="reflectconstruct">Reflect.construct()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectconstruct"></a></h3>
<blockquote>
<p>类似于 new 操作符构造函数，相当于运行<code>new target(...args)</code></p>
</blockquote>
<ul>
<li>如果 target 不是构造函数，抛出 TypeError</li>
<li>以 target(如果 newTarget 存在，则为 newTarget) 函数为构造函数，argumentList 为其初始化参数的对象实例</li>
</ul>
<ol>
<li><code>target</code>:被运行的目标<strong>构造函数</strong></li>
<li><code>argumentsList</code>:类数组，目标构造函数调用时的参数</li>
<li><code>newTarget</code>(可选):作为新创建对象的原型对象的 constructor 属性，参考<code>new.target</code>操作符，默认值为 target</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">function</span> <span class="hl-title function_">OneClass</span>(<span class="hl-params"></span>) {
  <span class="hl-variable language_">this</span>.<span class="hl-property">name</span> = <span class="hl-string">"one"</span>;
}

<span class="hl-keyword">function</span> <span class="hl-title function_">OtherClass</span>(<span class="hl-params"></span>) {
  <span class="hl-variable language_">this</span>.<span class="hl-property">name</span> = <span class="hl-string">"other"</span>;
}

<span class="hl-comment">// 创建一个对象：</span>
<span class="hl-keyword">const</span> obj1 = <span class="hl-title class_">Reflect</span>.<span class="hl-title function_">construct</span>(<span class="hl-title class_">OneClass</span>, args, <span class="hl-title class_">OtherClass</span>);

<span class="hl-comment">// 与上述方法等效：</span>
<span class="hl-keyword">const</span> obj2 = <span class="hl-title class_">Object</span>.<span class="hl-title function_">create</span>(<span class="hl-title class_">OtherClass</span>.<span class="hl-property"><span class="hl-keyword">prototype</span></span>);
<span class="hl-title class_">OneClass</span>.<span class="hl-title function_">apply</span>(obj2, args);
</code></pre>
<ol>
<li>
<p>当使用<code>Object.create()</code>和<code>Function.prototype.apply()</code>时，如果不使用 new 操作符调用构造函数，构造函数内部的 new.target 值会指向 undefined</p>
</li>
<li>
<p>当调用<code>Reflect.construct()</code>来创建对象，new.target 值会自动指定到 target(或者 newTarget，前提是 newTarget 指定了)</p>
</li>
</ol>
<h3 id="reflectdefineproperty">Reflect.defineProperty()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectdefineproperty"></a></h3>
<blockquote>
<p>基本等同于<code>Object.defineProperty()</code>方法唯一不同是返回 Boolean 值</p>
</blockquote>
<ul>
<li>注意：如果 target 不是 Object，抛出一个 TypeError</li>
<li>Boolean 值指示了属性是否被成功定义</li>
</ul>
<ol>
<li><code>target</code>:目标对象</li>
<li><code>propertyKey</code>:要定义或修改的属性的名称</li>
<li><code>attributes</code>:要定义或修改的属性的描述</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">let</span> obj = { <span class="hl-string">"x"</span>: <span class="hl-number">2</span> };
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">defineProperty</span>(obj, <span class="hl-string">"y"</span>, { <span class="hl-attr">value</span>: <span class="hl-number">7</span> }); <span class="hl-comment">// true</span>
<span class="hl-variable language_">console</span>.<span class="hl-title function_">log</span>(obj); <span class="hl-comment">//{x: 2, y: 7}</span>
</code></pre>
<h3 id="reflectdeleteproperty">Reflect.deleteProperty()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectdeleteproperty"></a></h3>
<blockquote>
<p>用于删除属性。类似<code>delete operator</code>但它是一个函数</p>
</blockquote>
<ul>
<li>如果 target 不是 Object，抛出一个 TypeError</li>
<li>返回<code>Boolean</code>值表明该属性是否被成功删除</li>
</ul>
<ol>
<li><code>target</code>:删除属性的目标对象</li>
<li><code>propertyKey</code>:需要删除的属性的名称</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">const</span> obj = { <span class="hl-attr">x</span>: <span class="hl-number">1</span>, <span class="hl-attr">y</span>: <span class="hl-number">2</span> };
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">deleteProperty</span>(obj, <span class="hl-string">"x"</span>); <span class="hl-comment">// true</span>
obj; <span class="hl-comment">// { y: 2 }</span>
</code></pre>
<ol>
<li>如果是数组：数组对象和下标</li>
<li>如果是一个空对象，删除属性，返回<code>true</code></li>
<li>如果属性不可配置<code>Object.freeze({foo: 1})</code>,则返回 false</li>
</ol>
<h3 id="reflecthas">Reflect.has()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflecthas"></a></h3>
<blockquote>
<p><code>Reflect.has(target, propertyKey)</code>作用与 in 操作符相同</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>返回一个 boolean 类型</li>
</ul>
<ol>
<li><code>target</code>:目标对象</li>
<li><code>propertyKey</code>:属性名，需要检查目标对象是否存在此属</li>
</ol>
<pre><code class="hl language-js"><span class="hl-comment">//如果该属性存在于原型链中，返回 true</span>
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">has</span>({ <span class="hl-attr">x</span>: <span class="hl-number">0</span> }, <span class="hl-string">"toString"</span>);

<span class="hl-comment">// Proxy 对象的 .has() 句柄方法</span>
<span class="hl-keyword">const</span> obj = <span class="hl-keyword">new</span> <span class="hl-title class_">Proxy</span>({}, {
  <span class="hl-title function_">has</span>(<span class="hl-params">t, k</span>) {
    <span class="hl-keyword">return</span> k.<span class="hl-title function_">startsWith</span>(<span class="hl-string">"door"</span>);
  },
});
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">has</span>(obj, <span class="hl-string">"doorbell"</span>); <span class="hl-comment">// true</span>
</code></pre>
<h3 id="reflectget">Reflect.get()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectget"></a></h3>
<blockquote>
<p>该方法与从对象<code>(target[propertyKey])</code>中读取属性类似，但它是通过一个函数执行来操作的</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>返回属性的值</li>
</ul>
<ol>
<li><code>target</code>:需要取值的目标对象</li>
<li><code>propertyKey</code>:需要获取的值的键值</li>
<li><code>receiver</code>:如果 target 对象中指定了 getter,receiver 则为 getter 调用时的 this 值</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">const</span> x = { <span class="hl-attr">p</span>: <span class="hl-number">1</span> };
<span class="hl-keyword">const</span> obj = <span class="hl-keyword">new</span> <span class="hl-title class_">Proxy</span>(x, {
  <span class="hl-title function_">get</span>(<span class="hl-params">t, k, r</span>) {
    <span class="hl-keyword">return</span> k + <span class="hl-string">"bar"</span>;
  },
});
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">get</span>(obj, <span class="hl-string">"foo"</span>); <span class="hl-comment">// "foobar"</span>
</code></pre>
<h3 id="reflectset">Reflect.set()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectset"></a></h3>
<blockquote>
<p>在一个对象上设置一个属性</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>返回一个布尔值表示是否设置成功</li>
</ul>
<ol>
<li><code>target</code>:设置属性的目标对象</li>
<li><code>propertyKey</code>:设置的属性的名称</li>
<li><code>value</code>:设置的值</li>
<li><code>receiver</code>:如果遇到 setter,receiver 则为 setter 调用时的 this 值</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">const</span> obj = {};
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">set</span>(obj, <span class="hl-string">"prop"</span>, <span class="hl-string">"value"</span>); <span class="hl-comment">// true</span>
obj.<span class="hl-property">prop</span>; <span class="hl-comment">// "value"</span>
</code></pre>
<h3 id="reflectgetownpropertydescriptor">Reflect.getOwnPropertyDescriptor()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectgetownpropertydescriptor"></a></h3>
<blockquote>
<p>如果属性在对象中存在，则返回给定的属性的属性描述符。否则返回<code>undefined</code></p>
</blockquote>
<ul>
<li>注意：如果目标不是<code>Object</code>,抛出一个
TypeError 而<code>Object.getOwnPropertyDescriptor</code>会将非对象强制转换成对象</li>
<li>如果在给定的目标对象中，则返回属性。如果存在，则返回 undefined</li>
</ul>
<ol>
<li>target:需要寻找属性的目标对象</li>
<li>propertyKey:获取自己的属性描述符的属性的名称</li>
</ol>
<pre><code class="hl language-js"><span class="hl-title class_">Reflect</span>.<span class="hl-title function_">getOwnPropertyDescriptor</span>({ <span class="hl-attr">x</span>: <span class="hl-string">"hello"</span> }, <span class="hl-string">"x"</span>);
<span class="hl-comment">// {value: "hello", writable: true, enumerable: true, configurable: true}</span>
</code></pre>
<h3 id="reflectgetprototypeof">Reflect.getPrototypeOf()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectgetprototypeof"></a></h3>
<blockquote>
<p>返回指定对象的原型</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>如果属性存在于给定的目标对象中，则返回属性描述符；否则，返回 undefined</li>
</ul>
<ol>
<li>target:需要寻找属性的目标对象</li>
</ol>
<pre><code class="hl language-js"><span class="hl-title class_">Reflect</span>.<span class="hl-title function_">getPrototypeOf</span>({});
<span class="hl-comment">// Object.prototype</span>
</code></pre>
<h3 id="reflectsetprototypeof">Reflect.setPrototypeOf()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectsetprototypeof"></a></h3>
<blockquote>
<p>它可设置对象的原型 (即内部的<code>[[Prototype]]</code>属性) 为另一个对象或
null，如果操作成功返回 true，否则返回 false</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>返回一个 Boolean 值证明已经初步成功设置</li>
</ul>
<ol>
<li><code>target</code>:设置目的的目标对象。</li>
<li><code>prototype</code>:对象的新原型 (一个对象或 null)</li>
</ol>
<pre><code class="hl language-js"><span class="hl-title class_">Reflect</span>.<span class="hl-title function_">setPrototypeOf</span>({}, <span class="hl-title class_">Object</span>.<span class="hl-property"><span class="hl-keyword">prototype</span></span>);
<span class="hl-comment">// true</span>
</code></pre>
<h3 id="reflectisextensible">Reflect.isExtensible()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectisextensible"></a></h3>
<blockquote>
<p>判断一个对象是否可扩展 (即是否能够添加新的属性)</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>返回一个 Boolean 值表明该对象是否可扩展</li>
</ul>
<ol>
<li><code>target</code>:检查是否可扩展的目标对象</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">const</span> frozen = <span class="hl-title class_">Object</span>.<span class="hl-title function_">freeze</span>({});
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">isExtensible</span>(frozen); <span class="hl-comment">//false</span>
</code></pre>
<h3 id="reflectownkeys">Reflect.ownKeys()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectownkeys"></a></h3>
<blockquote>
<p>返回一个由目标对象自身的属性键组成的数组</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>由目标对象的自身属性键组成的 Array</li>
</ul>
<ol>
<li><code>target</code>:检查是否可扩展的目标对象</li>
</ol>
<pre><code class="hl language-js"><span class="hl-title class_">Reflect</span>.<span class="hl-title function_">ownKeys</span>({ <span class="hl-attr">z</span>: <span class="hl-number">3</span>, <span class="hl-attr">y</span>: <span class="hl-number">2</span>, <span class="hl-attr">x</span>: <span class="hl-number">1</span> });
<span class="hl-comment">// [ "z", "y", "x" ]</span>
</code></pre>
<h3 id="reflectpreventextensions">Reflect.preventExtensions()<a class="anchor" aria-label="Anchor" aria-hidden="true" data-anchorjs-icon="🔗" href="#reflectpreventextensions"></a></h3>
<blockquote>
<p>阻止新属性添加到对象 (例如：防止将来对对象的扩展被添加到对象中)</p>
</blockquote>
<ul>
<li>注意：如果目标对象不是 Object 类型，则抛出 TypeError</li>
<li>返回一个价值保证 Boolean 目标对象是否成功被设置为不可扩展</li>
</ul>
<ol>
<li><code>target</code>:阻止扩展的目标对象</li>
</ol>
<pre><code class="hl language-js"><span class="hl-keyword">const</span> empty = {};
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">isExtensible</span>(empty); <span class="hl-comment">//true</span>
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">preventExtensions</span>(empty);
<span class="hl-title class_">Reflect</span>.<span class="hl-title function_">isExtensible</span>(empty); <span class="hl-comment">//false</span>
</code></pre>
        </article></main><script src="https://giscus.app/client.js"
        data-repo="fwqaaq/fwqaaq.github.io"
        data-repo-id="R_kgDOHCFK2A"
        data-category="Show and tell"
        data-category-id="DIC_kwDOHCFK2M4CYOLh"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async></script>